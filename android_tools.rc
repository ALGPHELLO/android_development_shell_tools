#!/bin/bash
# ======================================
#   Developed by Adrian DC - 2015-2016
# ======================================

# === Binary Editor ===
function binaryeditor()
{
  if [ -z "${1}" ]; then
    echo " Usage : binaryeditor patternsearch [binariespath] [replacement]";
    return;
  fi;

  # Variables
  local PATTERN="${1}";
  local FILES="${2:-.}";
  local REPLACEMENT="${3}";
  local REPLACE='';
  local STRINGS='';
  PATTERN=${PATTERN//\*/.\*};
  PATTERN=${PATTERN//./.};

  # Headers
  echo '';
  if [ ! -z "${REPLACEMENT}" ]; then
    echo -e " \e[1;31m=== Replacing '${PATTERN}' with '${REPLACEMENT}' in ${FILES} ===\e[0m";
  else
    echo -e " \e[1;31m=== Searching '${PATTERN}' in ${FILES} ===\e[0m";
  fi;
  echo '';

  # Search files
  for FILE in $(find ${FILES} -not -path "*.git/*" -not -path "*.repo/*" | sort); do

    # File / directory detection
    FILE=$(readlink -f "${FILE}");
    if [ -d ${FILE} ]; then
      continue;
    fi;

    # Replacement mode
    if [ ! -z "${REPLACEMENT}" ]; then
      STRINGS=$(strings ${FILE} | grep "${PATTERN}" | sort -u -r);

      # Information found
      if [ ! -z "${STRINGS}" ]; then
        printf "   \e[1;37m${FILE} :\e[0m ${STRINGS} ";
        for OLD_STRING in ${STRINGS};
        do
          NEW_STRING=${OLD_STRING//${PATTERN}/${REPLACEMENT}};

          # String conversions
          OLD_STRING_HEX="$(echo -n ${OLD_STRING} | xxd -g 0 -u -ps -c 256)00";
          NEW_STRING_HEX="$(echo -n ${NEW_STRING} | xxd -g 0 -u -ps -c 256)00";

          # Dimensions security
          if [ ${#NEW_STRING_HEX} -le ${#OLD_STRING_HEX} ]; then
            while [ ${#NEW_STRING_HEX} -lt ${#OLD_STRING_HEX} ];
            do
              NEW_STRING_HEX="${NEW_STRING_HEX}00";
            done;

            # Modification confirmation
            printf '\e[1;36m[y/N] \e[0m';
            read -s -d'' -s -n1 REPLACE;
            if [[ "${REPLACE}" == 'y' || "${REPLACE}" == 'Y' ]]; then
              hexdump -ve '1/1 "%.2X"' ${FILE} | \
                sed "s/${OLD_STRING_HEX}/${NEW_STRING_HEX}/g" | \
                xxd -r -p > ${FILE}.tmp;
              chmod --reference ${FILE} ${FILE}.tmp;
              mv ${FILE}.tmp ${FILE};
              echo -e '\e[1;32mDone!\e[0m';
            else
              echo -e '\e[1;33mIgnored.\e[0m';
            fi;

          # String overflow
          else
            echo -e '\e[1;36m[N] \e[1;33mString too long...\e[0m';
          fi;
        done;

      # Information not found
      else
        STRINGS=$(strings ${FILE} | grep ${REPLACEMENT} | sort -u -r);
        if [ ! -z "${STRINGS}" ]; then
          echo -e "   \e[1;37m${FILE}:\e[0m ${REPLACEMENT} \e[1;33mFound.\e[0m";
        fi;
      fi;

    # Search mode
    else
      STRINGS=$(strings ${FILE} | grep "${PATTERN}" | sort -u -r | tr '\n' ',');
      if [ ! -z "${STRINGS}" ]; then
        echo -e "   \e[1;37m${FILE}:\e[1;33m ${STRINGS}\e[0m";
      fi;
    fi;

  done;
  echo '';
}

# === Libraries Hunter ===
function librarieshunter()
{
  if [ -z "${1}" ]; then
    echo " Usage : librarieshunter binariespath";
    return;
  fi;

  local FILES="${1}";
  local FILE_NAME='';
  local FILE_REFERENCED='';
  local LIB_NAME='';

  # Scan the libraries
  echo '';
  echo -e " \e[1;31m=== Searching missing libraries in ${FILES} ===\e[0m";
  echo '';
  for FILE in $(find ${FILES} -not -path "*.git/*" -not -path "*.repo/*" | sort);
  do
    FILE=$(readlink -f "${FILE}");
    if [ -d ${FILE} ]; then continue; fi;

    # Internal references
    STRINGS=$(strings ${FILE} | grep "\\.so" | sort -u -r | tr '\n' ',');
    if [ ! -z "${STRINGS}" ]; then
      STRINGS=${STRINGS//,/ };
      echo -e "   \e[1;37m${FILE}:\e[1;33m ${STRINGS}\e[0m";

      # Search missing references
      for LIB in ${STRINGS};
      do
        if [[ ! "${LIB}" =~ '.so' ]]; then continue; fi;

        LIB_NAME=$(basename ${LIB});
        if [ -z "$(find $(dirname ${FILES}) -name ${LIB_NAME})" ]; then
          echo -e "    \e[1;37m- Missing reference: \e[1;31m${LIB_NAME}\e[0m";
        fi;
      done;

      # Search unused library
      FILE_NAME=$(basename "${FILE}");
      FILE_REFERENCED='';
      for FILE_SUB in $(find ${FILES} -not -path "*.git/*" -not -path "*.repo/*" | sort);
      do
        FILE_SUB=$(readlink -f "${FILE_SUB}");
        if [ -d "${FILE_SUB}" ] || [ "${FILE}" = "${FILE_SUB}" ]; then continue; fi;
        STRINGS_SUB=$(strings ${FILE_SUB} | grep "${FILE_NAME}" | sort -u -r | tr '\n' ',');
        if [ ! -z "${STRINGS_SUB}" ]; then
          FILE_REFERENCED='true';
          break;
        fi;
      done;
      if [ -z "${FILE_REFERENCED}" ]; then
        echo -e "    \e[1;31m- Unused library: ${FILE_NAME}\e[0m";
      fi;
    fi;
  done;
  echo '';
}

# === Hastebin ===
function haste()
{
  # Based upon https://github.com/seejohnrun/haste-client
  # Usage : command | haste or haste file
  tmp=$(mktemp);
  if [ ! -z "${1}" ] && [ -f "${1}" ]; then
    cat "${1}" | tee ${tmp};
  else
    cat | tee ${tmp};
  fi;
  echo '';
  url=$(timeout 10 curl -X POST -s --data-binary @"${tmp}" --connect-timeout 5 http://hastebin.com/documents \
      | awk -F '"' '{ print "http://hastebin.com/"${4}; }');
  echo "${url}";
  xdg-open "${url}" &
  echo '';
  rm ${tmp};
}

