#!/bin/bash
#
# Copyright 2015-2017 Adrian DC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# === Git Branch Pusher ===
function gitbranchpusher()
{
  # Usage: gitbranchpusher [y/n] [remote_url] [branch] (Push to project specific branch)

  # Variables
  local project_dir=${PWD};
  local repo_dir=${PWD};
  local param_send=${1};
  local remote=${2:-project};
  local project_branch=${3};

  # Check project
  if [ ! -d "${project_dir}/.git" ]; then
    echo '';
    echo ' Current project was not found...';
    echo '';
    return;
  fi;

  # Find repository
  while [[ "${repo_dir}" != '/' && ! -d "${repo_dir}/.repo" ]]; do
    repo_dir=$(readlink -f "${repo_dir}/..");
  done;
  if [ ! -d "${repo_dir}/.repo" ]; then
    echo '';
    echo ' Repository was not found';
    echo '';
    return;
  fi;

  # Project target
  project_dir=${project_dir#${repo_dir}/};
  if [ -z "${project_branch}" ]; then
    project_branch=${project_dir//\//_};
  fi;

  # Status information
  echo '';
  echo " Project directory: ${project_dir}";
  echo " Project branch: ${project_branch}";
  echo " Repository path: ${repo_dir}";
  echo '';

  # Check 'project' remote existence
  if [ "${remote}" = 'project' ]; then
    if ! git ls-remote --exit-code 'project' > /dev/null 2>&1; then
      echo -e " \e[1;33mInformation:\e[0m Remote 'project' not found. Launching 'gitrap'...";
      gitrap;
      echo '';
    fi;
  fi;

  # Fetch upstream remote
  git fetch "${remote}" "${project_branch}";
  git rev-list --left-right --count FETCH_HEAD...HEAD;
  echo '';

  # Confirmation
  command="git push -f ${remote} HEAD:refs/heads/${project_branch}";
  echo " ${command}";
  echo -n '  > Proceed with project push [y/N] ? ';
  notify-send "gitbranchpusher: Push ${project_dir} ?" 2> /dev/null;
  if [ -z "${param_send}" ]; then
    read -r -t 20 key;
  else
    key=y;
    echo "${key}";
  fi;

  # Upload to remote
  echo '';
  if [ "${key}" = 'y' ] || [ "${key}" = 'Y' ]; then
    ${command};
  elif [ "${key}" = 'n' ] || [ "${key}" = 'N' ]; then
    echo '  < Upload ignored. Consider uploading later';
  else
    echo '  < Upload ignored after timeout... Consider uploading later';
  fi;
  echo '';
}

# === Android Project Paths ===
function androidprojectpaths()
{
  # Usage
  if [ -z "${1}" ] || [ -z "${2}" ]; then
    echo '';
    echo ' Usage: androidprojectpaths <owner> <project_name> (Android project remote paths list)';
    echo '';
    return;
  fi;

  # Android project remote paths list
  git ls-remote --heads "https://github.com/${1}/${2}.git" \
      2> /dev/null \
      | sed 's/.*refs\/heads\///' \
      | grep -v 'local_manifests' \
      | sed 's/_/\//g';
}

# === Android Project Patcher ===
function androidprojectpatcher()
{
  # Usage
  if [ -z "${1}" ]; then
    echo '';
    echo ' Usage: androidprojectpatcher <owner> <project_name> <email> [specific_path] (Android project patcher)';
    echo '';
    return 1;
  fi;

  # Variables
  local project_owner=${1};
  local project_name=${2};
  local project_email=${3};
  local project_specific_inputs=("${@:4}");
  local android_top;
  local project_paths;
  local projects_specific=;
  local currentdir=${PWD};

  # ==========================================================
  # Load Android tools
  if [ -z "$(type -t croot)" ]; then
    while [ ! -e './build/envsetup.sh' ]; do
      cd ../;
    done;
    source ./build/envsetup.sh;
  fi;
  cd "${currentdir}";

  # ==========================================================
  # Automated key shortcut
  local key_input=;
  local key_automated_patch=;
  local key_automated_push=;
  if [[ "${project_specific_inputs[*]}" == 'a' ]] || \
      [[ "${project_specific_inputs[*]}" == 'y' ]] || \
      [[ "${project_specific_inputs[*]}" == 'n' ]]; then
    key_input=${project_specific_inputs[*]};
    project_specific_inputs=();
  fi;

  # ==========================================================
  # Detect 'sync' input
  if [ "${project_specific_inputs[*]}" = 'sync' ]; then
    androidprojectsync "${project_owner}" "${project_name}";
    return;
  fi;

  # ==========================================================
  # Detect 'unshallow' input
  if [ "${project_specific_inputs[*]}" = 'unshallow' ]; then
    androidprojectunshallow "${project_owner}" "${project_name}";
    return;
  fi;

  # ==========================================================
  # Extract specific projects paths
  if [ ! -z "${project_specific_inputs[*]}" ]; then
    android_top=$(gettop);
    for path in "${project_specific_inputs[@]}"; do
      path=$(readlink -f "${path}");
      projects_specific="${projects_specific} ${path#${android_top}/}";
    done;
  fi;

  # Automated remote changes list detection
  project_paths=$(androidprojectpaths "${project_owner}" "${project_name}");

  # ==========================================================
  # Repo root
  croot;

  # ==========================================================
  # Variables
  local commits_list=();
  local commits_result;
  local commits_todo;
  local git_revs_count;
  local git_revs_count_local;
  local path_branch;
  local project_github;
  local user_is_owner='';

  # Check current user rights
  if [ "$(git config --global user.email)" = "${project_email}" ]; then
    user_is_owner='true';
  fi;

  # Projects loader
  for path in ${projects_specific:-${project_paths}}; do

    # Project selection
    path=${path%/};
    path_branch=${path//\//_};
    echo '';
    echo -e " \e[1;37m=== ${path} [${path_branch}] ===\e[0m";
    echo '';
    croot;

    # Ignore missing git projects
    if [ ! -d "${path}/.git" ]; then
      echo '  .git project not found, ignoring...';
      continue;
    fi;
    cd "${path}/";

    # Targets selection
    project_github="https://github.com/${project_owner}/${project_name}.git";

    # Fetch
    if ! git fetch "${project_github}" "${path_branch}"; then
      echo 'Remote project branch not found, ignoring...';
      continue;
    fi;

    # Compare
    git_revs_count=$(git rev-list --left-right --count HEAD...FETCH_HEAD | tail -n 1);
    git_revs_count_local=$(echo "${git_revs_count:-0}" | awk '{ print $1 }');
    git_revs_count_remote=$(echo "${git_revs_count:-0}" | awk '{ print $2 }');
    echo '';
    echo -e "  \e[1;31m> Differences: ${git_revs_count:-Missing history}\e[0m";

    # Handle unupdated projects
    if [ "${git_revs_count_local}" -ne 0 ] && [ "${git_revs_count_remote}" -ne 0 ]; then
      echo '';
      echo -e '  \e[1;37m> Commands: Y (Rebase on new changes)';
      echo -e '              n (Use the old project sources)';
      if [ ! -z "${user_is_owner}" ]; then
      echo -e '              a (Automatically update all projects)';
      fi;
      echo -e '              l (Automatically patch all projects)';
      if [ ! -z "${user_is_owner}" ]; then
        echo -e '              p (Push local changes upstream)';
      fi;
      echo '';
      echo -en '  \e[1;33m> Choice to patch and update the project ? \e[0m';
      if [ -z "${key_input}" ]; then
        read -r -t 20 key;
      else
        key=${key_input};
        echo "${key}";
      fi;
      echo '';

      # Adapt patcher to key input
      if [ -z "${key}" ]; then
        key_input=;
        key_automated_patch=y;
        key_automated_push=;
      elif [ "${key}" = 'a' ] || [ "${key}" = 'A' ]; then
        key_input=a;
        key_automated_patch=y;
        key_automated_push=y;
      elif [ "${key}" = 'n' ] || [ "${key}" = 'N' ]; then
        key_input=;
        key_automated_patch=n;
        key_automated_push=n;
      elif [ "${key}" = 'l' ] || [ "${key}" = 'L' ]; then
        key_input=l;
        key_automated_patch=y;
        key_automated_push=n;
      elif [ "${key}" = 'p' ] || [ "${key}" = 'P' ]; then
        key_input=;
        key_automated_patch=n;
        key_automated_push=y;
      elif [ "${key}" = 'y' ] || [ "${key}" = 'Y' ]; then
        key_input=;
        key_automated_patch=y;
        key_automated_push=;
      fi;

      # Rebase the tree
      if [ "${key_automated_patch}" = 'y' ]; then

        # Abort last cherry-pick
        echo '';
        git cherry-pick --abort &> /dev/null;

        # Detect commits to pick - Detect own updated project
        readarray -t commits_list <<< "$(git log --committer="${project_email}" --committer='marker.commit' --reverse --format=format:%H HEAD)";
        if [ -z "${commits_list[*]}" ]; then

          # Detect commits to pick - Detect own cherry-picked commits
          readarray -t commits_list <<< "$(git log --committer="${project_email}" --committer='marker.commit' --reverse --format=format:%H FETCH_HEAD)";

        # Detect commits to pick - Detect own cherry-picked additional commits in an own updated project
        else
          readarray -t commits_list <<< "$(git log --format=format:'%H|%ce' FETCH_HEAD | sed "s/|${project_email}//g" | sed '/|/q' | sed 's/|marker.commit//' | sed 's/|.*//' | tac)";
          if [ -z "${commits_list[*]}" ] || [ "${#commits_list[@]}" -gt "${git_revs_count_remote}" ]; then

            # Detect commits to pick - Detect own cherry-picked commits based on commits delta
            readarray -t commits_list <<< "$(git rev-list --reverse FETCH_HEAD~"${git_revs_count_remote}"..FETCH_HEAD)";

          fi;
        fi;

        # Pick all commits
        for sha1 in "${commits_list[@]}"; do
          git cherry-pick "${sha1}";
          commits_result=${?};

          # Failed update
          if [ ${commits_result} -ne 0 ] && [ ${commits_result} -ne 1 ] || ! git diff-index --quiet HEAD --; then
            commits_todo=${commits_list[*]};
            commits_todo=${commits_todo#*${sha1}};
            echo '';
            echo '  < Automatic update failed...';
            echo "     Tried to add following commits: ${sha1} ${commits_todo}";
            echo '  > Manually fix then push with :';
            echo "     gitbranchpusher '${key_automated_patch}' '${project_github}' '${path_branch}';";
            echo '';
            return 1;
          fi;

          # Detect marker commits and tag them
          if git --no-pager log -1 --pretty=format:"%ae" "${sha1}" | grep -q 'marker.commit'; then
            gitcamarker;
          fi;

        done;

        # Automatic push
        if [ ! -z "${user_is_owner}" ]; then
          gitbranchpusher "${key_automated_push}" "${project_github}" "${path_branch}";
        fi;

      # Only push the project
      elif [ "${key_automated_push}" = 'y' ]; then

        # Automatic push
        if [ ! -z "${user_is_owner}" ]; then
          gitbranchpusher "${key_automated_push}" "${project_github}" "${path_branch}";
        fi;

      # Project is ready
      else
        git reset --hard FETCH_HEAD;
        git stash -u;
      fi;

    # Handle unupdated remotes
    elif [ "${git_revs_count_local}" -ne 0 ]; then

      # Automatic push
      if [ ! -z "${user_is_owner}" ]; then
        gitbranchpusher "${key_automated_push}" "${project_github}" "${path_branch}";
      fi;

    # Project is ready
    else
      git reset --hard FETCH_HEAD;
      git stash -u;
    fi;

  done;

  # ==========================================================
  # Return to current folder
  echo '';
  cd "${currentdir}";
  return 0;
}

# === Android Project Rebaser ===
function androidprojectrebaser()
{
  # Usage
  if [ -z "${3}" ]; then
    echo '';
    echo ' Usage: androidprojectrebaser <upstream_repository_if_not_origin> <project_branch> <"project_paths::name::branch"> [specific_path] (Android project rebaser)';
    echo '';
    return;
  fi;

  # Variables
  local upstream_repository=${1};
  local project_branch=${2};
  local project_paths=${3};
  local project_specific=${4};
  local currentdir=${PWD};

  # Automated key shortcut
  local key_automated=;
  if [[ "${project_specific}" == 'y' ]] || [[ "${project_specific}" == 'n' ]]; then
    key_automated=${project_specific};
    project_specific=;
  fi;

  # Repo root
  if [ -z "$(type -t croot)" ]; then
    while [ ! -e './build/envsetup.sh' ]; do
      cd ../;
    done;
    source ./build/envsetup.sh;
  fi;
  croot;

  # ==========================================================
  # Variables
  local git_revs_count;
  local git_revs_count_local;
  local git_username;
  local path;
  local path_branch;
  local path_name;
  local path_temp;
  local project_fetch;
  local project_github;
  local project_unfinished;
  local push_command;
  local push_branch;
  local upstream_branch;
  local upstream_project;

  # Username and fallback
  git_username=$(githubusername 2> /dev/null);
  git_username=${git_username:-AdrianDC};

  # Projects loader
  for project in ${project_paths}; do

    # Jump to specific project
    if [ ! -z "${project_specific}" ]; then
      if [[ ! "${project}" == *"${project_specific%/}::"* ]]; then
        continue;
      fi;
    fi;

    # Project selection
    path=${project%%::*};
    path_temp=${project#*::};
    path_name=${path_temp%::*};
    project_fetch=;
    upstream_project=${upstream_repository}/${path_name:-.};
    upstream_branch=${path_temp#*::};
    upstream_branch=${upstream_branch:-${project_branch}};
    push_branch=${upstream_branch};

    # Variables generic changes
    if [ ! -z "${project_branch}" ]; then
      push_branch=${project_branch};
    fi;
    if [ -z "${upstream_project}" ]; then
      upstream_project=${upstream_repository};
    fi;

    # Project introduction
    echo '';
    echo " === ${path} [${upstream_project} @${upstream_branch}] ===";
    croot;

    # Ignore non-git projects
    if [ ! -d "${path}/.git" ]; then
      echo '  .git project not found, ignoring...';
      continue;
    fi;
    cd "${path}/";

    # Loop until project ready
    project_unfinished=1;
    while [ ${project_unfinished} -eq 1 ]; do

      # Standard origin repository
      if [[ "${upstream_repository}" == 'origin' ]]; then
        project_fetch=origin;
        if ! git ls-remote --exit-code ${project_fetch} > /dev/null 2>&1; then
          echo ' Branch origin was not found...';
          gitrao;
          continue;
        fi;

      # SonyXperiaDev origin repository
      elif [[ "${upstream_repository}" == 'sodp' ]]; then
        project_fetch=origin;
        if ! git ls-remote --exit-code ${project_fetch} > /dev/null 2>&1; then
          echo ' Branch origin was not found...';
          gitraos;
          continue;
        fi;

      # Custom upstream repository
      else
        project_fetch=upstream;
        if ! git ls-remote --exit-code ${project_fetch} > /dev/null 2>&1; then
          echo ' Branch upstream was not found...';
          gitremoteset upstream "https://github.com/${upstream_project}";
          continue;
        fi;
      fi;

      # Check private remote
      if ! git ls-remote --exit-code "${git_username}" > /dev/null 2>&1; then
        echo " Branch ${git_username} was not found...";
        gitraa;
        continue;
      fi;

      # Fetch and compare
      git fetch "${project_fetch}" "${upstream_branch}";
      git_revs_count=$(git rev-list --left-right --count HEAD...FETCH_HEAD | tail -n 1);
      git_revs_count_local=$(echo "${git_revs_count}" | awk '{ print $1 }');
      git_revs_count_remote=$(echo "${git_revs_count}" | awk '{ print $2 }');
      echo " Differences: ${git_revs_count}";

      # Handle unupdated projects
      if [ "${git_revs_count_remote}" -ne 0 ]; then
        echo '';
        echo -n '  > Rebase onto newest changes [Y/a/n] ? ';
        if [ -z "${key_automated}" ]; then
          read -r -t 20 key;
          if [ "${key}" = 'a' ] || [ "${key}" = 'A' ]; then
            key_automated=y;
          fi;
        else
          key=${key_automated};
        fi;

        # Rebase the tree
        if [ ! "${key}" = 'n' ] && [ ! "${key}" = 'N' ]; then
          echo '';
          git rebase --abort;
          git rebase FETCH_HEAD;
          push_command="git push -f ${git_username} HEAD:refs/heads/${push_branch}";
          echo '';
          echo -n "  > ${push_command} [y/a/N] ? ";
          notify-send "androidprojectrebaser: Push ${path} ?" 2> /dev/null;
          if [ -z "${key_automated}" ]; then
            read -r -t 20 key;
            if [ "${key}" = 'a' ] || [ "${key}" = 'A' ]; then
              key_automated=y;
            fi;
          else
            key=${key_automated};
          fi;

          # Push the tree
          echo '';
          if [[ "${key}" == 'y' ]] || [[ "${key}" == 'Y' ]]; then
            ${push_command};
          elif [[ ! "${key}" == 'n' ]] && [[ ! "${key}" == 'N' ]]; then
            echo '  < Upload ignored after timeout... Consider uploading later';
            echo '';
          fi;

        # Project is ready, break the loop
        else
          project_unfinished=0;
        fi;

      # Project is ready, break the loop
      else
        project_unfinished=0;
      fi;

    done;

    # Cleanup
    git reset --hard HEAD;
    git stash -u;

  done;

  # ==========================================================
  # Return to current folder
  echo '';
  cd "${currentdir}";
}

# === Android Project For Each Path ===
function androidprojectforeach()
{
  # Usage
  if [ -z "${1}" ] || [ -z "${2}" ] || [ -z "${3}" ]; then
    echo '';
    echo ' Usage: androidprojectforeach <owner> <project_name> <"commands"> (Android project paths commands runner)';
    echo '';
    return;
  fi;

  # Variables
  local path;

  # Android project remote paths list
  for path in $(androidprojectpaths "${1}" "${2}"); do

    # Access path
    croot;
    cd "${path}";

    # Information
    echo '';
    echo "[${path}]";

    # Run commands
    ${3};

  done;

  # Return to repo root
  croot;
  echo '';
}

# === Android Project Sync ===
function androidprojectsync()
{
  # Usage
  if [ -z "${1}" ] || [ -z "${2}" ]; then
    echo '';
    echo ' Usage: androidprojectsync <owner> <project_name> (Android project paths repo syncer)';
    echo '';
    return;
  fi;

  # Variables
  local path;

  # Android project remote paths list
  for path in $(androidprojectpaths "${1}" "${2}"); do

    # Access path
    croot;
    cd "${path}";

    # Information
    echo '';
    echo " androidproject: Syncing '${path}' path...";

    # Fetch and reset
    git fetch "$(repogetremote)" "$(repogetbranch)" 2>&1;
    git reset --hard FETCH_HEAD;

  done;

  # Return to repo root
  croot;
  echo '';
}

# === Android Project Unshallow ===
function androidprojectunshallow()
{
  # Usage
  if [ -z "${1}" ] || [ -z "${2}" ]; then
    echo '';
    echo ' Usage: androidprojectunshallow <owner> <project_name> (Android project paths unshallower)';
    echo '';
    return;
  fi;

  # Variables
  local path;

  # Android project remote paths list
  for path in $(androidprojectpaths "${1}" "${2}"); do

    # Access path
    croot;
    cd "${path}";

    # Information
    echo '';
    echo " androidprojectunshallow: Checking '${path}' shallow status...";

    # Fetch and unshallow
    git fetch --unshallow "$(repogetremote)" "$(repogetbranch)" 2>&1 \
	    | grep -v 'on a complete repository does not make sense';

  done;

  # Return to repo root
  croot;
  echo '';
}
